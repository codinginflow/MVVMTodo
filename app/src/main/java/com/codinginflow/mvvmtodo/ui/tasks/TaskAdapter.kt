package com.codinginflow.mvvmtodo.ui.tasks

import android.view.LayoutInflater
import android.view.ViewGroup
import android.widget.AdapterView
import androidx.core.view.isVisible
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.codinginflow.mvvmtodo.data.Task
import com.codinginflow.mvvmtodo.databinding.ItemTaskBinding

class TaskAdapter(private val listener : OnItemClickListener) : ListAdapter<Task, TaskAdapter.TasksViewHolder>(DiffCallBack()) { //Cuz we're using Flow and want some additional features like animations, etc.. we don't use normal adapters. In our case, when something in the table changes, we get a completely new table of tasks through the flow and not a single changed item, which makes it suitable to use listAdapter(which is subClass of recyclerViewAdapters) as it compares the data pre and post change of the table. Most importantly, it does everything in the background thread.

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): TasksViewHolder {   //Inside this func we define how one of our viewHolder class should be instantiated.
        val binding = ItemTaskBinding.inflate(LayoutInflater.from(parent.context), parent, false)  //Before we use to create instance of view and pass it on to the viewHolderClass, but now it needs binding.
        return TasksViewHolder(binding)
    }

    override fun onBindViewHolder(holder: TasksViewHolder, position: Int) {  //Inside this func we define how we bind data to the viewHolder, which just calls the below bind() func.
        val currentItem = getItem(position)  //getItem() is func of rhe recyclerview.
        holder.bind(currentItem)
    }

    //The below viewHolder is the class which knows where the single view in the itemLayout are, and what data it should possess.
    inner class TasksViewHolder(private val binding : ItemTaskBinding) : RecyclerView.ViewHolder(binding.root){
        //binding is replacement for findViewId with compile time safety and is easy to use. Notice that the above ItemTaskBinding is autogenerated and has same name as that of the layout item_task.

        //We're passing the checked state of the tasks to the fragment through the interface so that the fragment can send this information to the viewModel. We're doing this within init block cuz, the code will be executed when the taskViewHolder is instantiated.
        init{
            //root : RootLayout
            binding.apply{
                //We're setting clickListener on the root cuz, we want to move to the next screen if clicked anywhere in the width.
                root.setOnClickListener {
                    val position = adapterPosition  //adapterPosition : Position of the viewHolder.
                    if(position != RecyclerView.NO_POSITION) {  /// RecyclerView.NO_POSITION : Constant for -1. This is used so that we are trying to access an invalid item. When an item is deleted, it gets animated off the list, and it's theoretically possible to click any item while it's animating, but is invalid.
                        val task = getItem(position)  //getItem() is method of adapter and hence make the class inner so that this class can access the functions of adapter. inner class is similar to static class, which enables us to access TaskAdapter from outside. This means we're tightly coupling viewHolder and the adapter as we're accessing getItem() , but it's fine here as they belong to each other anyways.
                        listener.onItemClick(task)
                    }
                }
                checkBoxCompleted.setOnClickListener {
                    val position = adapterPosition
                    if(position != RecyclerView.NO_POSITION) {  /// RecyclerView.NO_POSITION : Constant for -1. This is used so that we are'nt trying to access an invalid item. When an item is deleted, it gets animated off the list, and it's theoretically possible to click any item while it's animating but is invalid.
                        val task = getItem(position)  //get the clicked task
                        listener.onCheckBoxClicked(task, checkBoxCompleted.isChecked)  //isChecked is inbuilt method of the widget.
                    }//This is to check the box appropriately
                }
            }
        }

        fun bind(task: Task){  //This func will later put the actual data into the different views of the layout.
            binding.apply {
                checkBoxCompleted.isChecked = task.completed
                textViewName.text = task.name
                textViewName.paint.isStrikeThruText = task.completed
                labelPriority.isVisible = task.important
            }
        }
    }

    interface OnItemClickListener{   //We make the fragment implement this interface as well the below methods and the adapters can call these methods on the fragment.
        fun onItemClick(task: Task)  //To move to the next screen.

        fun onCheckBoxClicked(task: Task, isChecked : Boolean)
    }  //By using this technique of making the interface middleMan between adapter and the fragment, we keep our fragment and adapter disconnected from each other. If we would call these methods directly on the taskFragment(using adapter and not interface), we'd couple them together directly and adapter would'nt be reusable.

    //As mentioned before, the listAdapter differentiates between items in the old and new list. But we've to manually tell it how it should do. We pass this class to it's constructor above.
    class DiffCallBack : DiffUtil.ItemCallback<Task>(){
        override fun areItemsTheSame(oldItem: Task, newItem: Task) = oldItem.id == newItem.id  //Two items representing the same logical item and this func knows when to move things around and continue considering them the same. As id is unique for each items, we can make us uniquely identify each item.

        override fun areContentsTheSame(oldItem: Task, newItem: Task) =  oldItem == newItem   //Here we've to tell the callBack, when the content within the item are changed so that it can refresh items on the screen. The data class automatically invokes equals method with the comparision operators. This way we compare all the properties passed to the constructor and any change to even one of the property will refresh all the items.
    }

}